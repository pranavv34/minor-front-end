{"ast":null,"code":"import { TextEncoder } from 'util';\nimport { Readable } from 'stream';\nimport utils from \"../utils.js\";\nimport readBlob from \"./readBlob.js\";\nconst BOUNDARY_ALPHABET = utils.ALPHABET.ALPHA_DIGIT + '-_';\nconst textEncoder = new TextEncoder();\nconst CRLF = '\\r\\n';\nconst CRLF_BYTES = textEncoder.encode(CRLF);\nconst CRLF_BYTES_COUNT = 2;\n\nclass FormDataPart {\n  constructor(name, value) {\n    const {\n      escapeName\n    } = this.constructor;\n    const isStringValue = utils.isString(value);\n    let headers = `Content-Disposition: form-data; name=\"${escapeName(name)}\"${!isStringValue && value.name ? `; filename=\"${escapeName(value.name)}\"` : ''}${CRLF}`;\n\n    if (isStringValue) {\n      value = textEncoder.encode(String(value).replace(/\\r?\\n|\\r\\n?/g, CRLF));\n    } else {\n      headers += `Content-Type: ${value.type || \"application/octet-stream\"}${CRLF}`;\n    }\n\n    this.headers = textEncoder.encode(headers + CRLF);\n    this.contentLength = isStringValue ? value.byteLength : value.size;\n    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;\n    this.name = name;\n    this.value = value;\n  }\n\n  async *encode() {\n    yield this.headers;\n    const {\n      value\n    } = this;\n\n    if (utils.isTypedArray(value)) {\n      yield value;\n    } else {\n      yield* readBlob(value);\n    }\n\n    yield CRLF_BYTES;\n  }\n\n  static escapeName(name) {\n    return String(name).replace(/[\\r\\n\"]/g, match => ({\n      '\\r': '%0D',\n      '\\n': '%0A',\n      '\"': '%22'\n    })[match]);\n  }\n\n}\n\nconst formDataToStream = (form, headersHandler, options) => {\n  const {\n    tag = 'form-data-boundary',\n    size = 25,\n    boundary = tag + '-' + utils.generateString(size, BOUNDARY_ALPHABET)\n  } = options || {};\n\n  if (!utils.isFormData(form)) {\n    throw TypeError('FormData instance required');\n  }\n\n  if (boundary.length < 1 || boundary.length > 70) {\n    throw Error('boundary must be 10-70 characters long');\n  }\n\n  const boundaryBytes = textEncoder.encode('--' + boundary + CRLF);\n  const footerBytes = textEncoder.encode('--' + boundary + '--' + CRLF + CRLF);\n  let contentLength = footerBytes.byteLength;\n  const parts = Array.from(form.entries()).map(_ref => {\n    let [name, value] = _ref;\n    const part = new FormDataPart(name, value);\n    contentLength += part.size;\n    return part;\n  });\n  contentLength += boundaryBytes.byteLength * parts.length;\n  contentLength = utils.toFiniteNumber(contentLength);\n  const computedHeaders = {\n    'Content-Type': `multipart/form-data; boundary=${boundary}`\n  };\n\n  if (Number.isFinite(contentLength)) {\n    computedHeaders['Content-Length'] = contentLength;\n  }\n\n  headersHandler && headersHandler(computedHeaders);\n  return Readable.from(async function* () {\n    for (const part of parts) {\n      yield boundaryBytes;\n      yield* part.encode();\n    }\n\n    yield footerBytes;\n  }());\n};\n\nexport default formDataToStream;","map":{"version":3,"sources":["/Users/pranavvuddagiri/Desktop/minorhome/node_modules/axios/lib/helpers/formDataToStream.js"],"names":["TextEncoder","Readable","utils","readBlob","BOUNDARY_ALPHABET","ALPHABET","ALPHA_DIGIT","textEncoder","CRLF","CRLF_BYTES","encode","CRLF_BYTES_COUNT","FormDataPart","constructor","name","value","escapeName","isStringValue","isString","headers","String","replace","type","contentLength","byteLength","size","isTypedArray","match","formDataToStream","form","headersHandler","options","tag","boundary","generateString","isFormData","TypeError","length","Error","boundaryBytes","footerBytes","parts","Array","from","entries","map","part","toFiniteNumber","computedHeaders","Number","isFinite"],"mappings":"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","sourcesContent":["import {TextEncoder} from 'util';\nimport {Readable} from 'stream';\nimport utils from \"../utils.js\";\nimport readBlob from \"./readBlob.js\";\n\nconst BOUNDARY_ALPHABET = utils.ALPHABET.ALPHA_DIGIT + '-_';\n\nconst textEncoder = new TextEncoder();\n\nconst CRLF = '\\r\\n';\nconst CRLF_BYTES = textEncoder.encode(CRLF);\nconst CRLF_BYTES_COUNT = 2;\n\nclass FormDataPart {\n  constructor(name, value) {\n    const {escapeName} = this.constructor;\n    const isStringValue = utils.isString(value);\n\n    let headers = `Content-Disposition: form-data; name=\"${escapeName(name)}\"${\n      !isStringValue && value.name ? `; filename=\"${escapeName(value.name)}\"` : ''\n    }${CRLF}`;\n\n    if (isStringValue) {\n      value = textEncoder.encode(String(value).replace(/\\r?\\n|\\r\\n?/g, CRLF));\n    } else {\n      headers += `Content-Type: ${value.type || \"application/octet-stream\"}${CRLF}`\n    }\n\n    this.headers = textEncoder.encode(headers + CRLF);\n\n    this.contentLength = isStringValue ? value.byteLength : value.size;\n\n    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;\n\n    this.name = name;\n    this.value = value;\n  }\n\n  async *encode(){\n    yield this.headers;\n\n    const {value} = this;\n\n    if(utils.isTypedArray(value)) {\n      yield value;\n    } else {\n      yield* readBlob(value);\n    }\n\n    yield CRLF_BYTES;\n  }\n\n  static escapeName(name) {\n      return String(name).replace(/[\\r\\n\"]/g, (match) => ({\n        '\\r' : '%0D',\n        '\\n' : '%0A',\n        '\"' : '%22',\n      }[match]));\n  }\n}\n\nconst formDataToStream = (form, headersHandler, options) => {\n  const {\n    tag = 'form-data-boundary',\n    size = 25,\n    boundary = tag + '-' + utils.generateString(size, BOUNDARY_ALPHABET)\n  } = options || {};\n\n  if(!utils.isFormData(form)) {\n    throw TypeError('FormData instance required');\n  }\n\n  if (boundary.length < 1 || boundary.length > 70) {\n    throw Error('boundary must be 10-70 characters long')\n  }\n\n  const boundaryBytes = textEncoder.encode('--' + boundary + CRLF);\n  const footerBytes = textEncoder.encode('--' + boundary + '--' + CRLF + CRLF);\n  let contentLength = footerBytes.byteLength;\n\n  const parts = Array.from(form.entries()).map(([name, value]) => {\n    const part = new FormDataPart(name, value);\n    contentLength += part.size;\n    return part;\n  });\n\n  contentLength += boundaryBytes.byteLength * parts.length;\n\n  contentLength = utils.toFiniteNumber(contentLength);\n\n  const computedHeaders = {\n    'Content-Type': `multipart/form-data; boundary=${boundary}`\n  }\n\n  if (Number.isFinite(contentLength)) {\n    computedHeaders['Content-Length'] = contentLength;\n  }\n\n  headersHandler && headersHandler(computedHeaders);\n\n  return Readable.from((async function *() {\n    for(const part of parts) {\n      yield boundaryBytes;\n      yield* part.encode();\n    }\n\n    yield footerBytes;\n  })());\n};\n\nexport default formDataToStream;\n"]},"metadata":{},"sourceType":"module"}
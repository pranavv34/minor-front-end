{"ast":null,"code":"'use strict';\n\nimport stream from 'stream';\nimport utils from '../utils.js';\nimport throttle from './throttle.js';\nimport speedometer from './speedometer.js';\nconst kInternals = Symbol('internals');\n\nclass AxiosTransformStream extends stream.Transform {\n  constructor(options) {\n    options = utils.toFlatObject(options, {\n      maxRate: 0,\n      chunkSize: 64 * 1024,\n      minChunkSize: 100,\n      timeWindow: 500,\n      ticksRate: 2,\n      samplesCount: 15\n    }, null, (prop, source) => {\n      return !utils.isUndefined(source[prop]);\n    });\n    super({\n      readableHighWaterMark: options.chunkSize\n    });\n    const self = this;\n    const internals = this[kInternals] = {\n      length: options.length,\n      timeWindow: options.timeWindow,\n      ticksRate: options.ticksRate,\n      chunkSize: options.chunkSize,\n      maxRate: options.maxRate,\n      minChunkSize: options.minChunkSize,\n      bytesSeen: 0,\n      isCaptured: false,\n      notifiedBytesLoaded: 0,\n      ts: Date.now(),\n      bytes: 0,\n      onReadCallback: null\n    };\n\n    const _speedometer = speedometer(internals.ticksRate * options.samplesCount, internals.timeWindow);\n\n    this.on('newListener', event => {\n      if (event === 'progress') {\n        if (!internals.isCaptured) {\n          internals.isCaptured = true;\n        }\n      }\n    });\n    let bytesNotified = 0;\n    internals.updateProgress = throttle(function throttledHandler() {\n      const totalBytes = internals.length;\n      const bytesTransferred = internals.bytesSeen;\n      const progressBytes = bytesTransferred - bytesNotified;\n      if (!progressBytes || self.destroyed) return;\n\n      const rate = _speedometer(progressBytes);\n\n      bytesNotified = bytesTransferred;\n      process.nextTick(() => {\n        self.emit('progress', {\n          'loaded': bytesTransferred,\n          'total': totalBytes,\n          'progress': totalBytes ? bytesTransferred / totalBytes : undefined,\n          'bytes': progressBytes,\n          'rate': rate ? rate : undefined,\n          'estimated': rate && totalBytes && bytesTransferred <= totalBytes ? (totalBytes - bytesTransferred) / rate : undefined\n        });\n      });\n    }, internals.ticksRate);\n\n    const onFinish = () => {\n      internals.updateProgress(true);\n    };\n\n    this.once('end', onFinish);\n    this.once('error', onFinish);\n  }\n\n  _read(size) {\n    const internals = this[kInternals];\n\n    if (internals.onReadCallback) {\n      internals.onReadCallback();\n    }\n\n    return super._read(size);\n  }\n\n  _transform(chunk, encoding, callback) {\n    const self = this;\n    const internals = this[kInternals];\n    const maxRate = internals.maxRate;\n    const readableHighWaterMark = this.readableHighWaterMark;\n    const timeWindow = internals.timeWindow;\n    const divider = 1000 / timeWindow;\n    const bytesThreshold = maxRate / divider;\n    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;\n\n    function pushChunk(_chunk, _callback) {\n      const bytes = Buffer.byteLength(_chunk);\n      internals.bytesSeen += bytes;\n      internals.bytes += bytes;\n\n      if (internals.isCaptured) {\n        internals.updateProgress();\n      }\n\n      if (self.push(_chunk)) {\n        process.nextTick(_callback);\n      } else {\n        internals.onReadCallback = () => {\n          internals.onReadCallback = null;\n          process.nextTick(_callback);\n        };\n      }\n    }\n\n    const transformChunk = (_chunk, _callback) => {\n      const chunkSize = Buffer.byteLength(_chunk);\n      let chunkRemainder = null;\n      let maxChunkSize = readableHighWaterMark;\n      let bytesLeft;\n      let passed = 0;\n\n      if (maxRate) {\n        const now = Date.now();\n\n        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {\n          internals.ts = now;\n          bytesLeft = bytesThreshold - internals.bytes;\n          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;\n          passed = 0;\n        }\n\n        bytesLeft = bytesThreshold - internals.bytes;\n      }\n\n      if (maxRate) {\n        if (bytesLeft <= 0) {\n          // next time window\n          return setTimeout(() => {\n            _callback(null, _chunk);\n          }, timeWindow - passed);\n        }\n\n        if (bytesLeft < maxChunkSize) {\n          maxChunkSize = bytesLeft;\n        }\n      }\n\n      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {\n        chunkRemainder = _chunk.subarray(maxChunkSize);\n        _chunk = _chunk.subarray(0, maxChunkSize);\n      }\n\n      pushChunk(_chunk, chunkRemainder ? () => {\n        process.nextTick(_callback, null, chunkRemainder);\n      } : _callback);\n    };\n\n    transformChunk(chunk, function transformNextChunk(err, _chunk) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (_chunk) {\n        transformChunk(_chunk, transformNextChunk);\n      } else {\n        callback(null);\n      }\n    });\n  }\n\n  setLength(length) {\n    this[kInternals].length = +length;\n    return this;\n  }\n\n}\n\nexport default AxiosTransformStream;","map":{"version":3,"sources":["/Users/pranavvuddagiri/Desktop/minorhome/node_modules/axios/lib/helpers/AxiosTransformStream.js"],"names":["stream","utils","throttle","speedometer","kInternals","Symbol","AxiosTransformStream","Transform","constructor","options","toFlatObject","maxRate","chunkSize","minChunkSize","timeWindow","ticksRate","samplesCount","prop","source","isUndefined","readableHighWaterMark","self","internals","length","bytesSeen","isCaptured","notifiedBytesLoaded","ts","Date","now","bytes","onReadCallback","_speedometer","on","event","bytesNotified","updateProgress","throttledHandler","totalBytes","bytesTransferred","progressBytes","destroyed","rate","process","nextTick","emit","undefined","onFinish","once","_read","size","_transform","chunk","encoding","callback","divider","bytesThreshold","Math","max","pushChunk","_chunk","_callback","Buffer","byteLength","push","transformChunk","chunkRemainder","maxChunkSize","bytesLeft","passed","setTimeout","subarray","transformNextChunk","err","setLength"],"mappings":"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","sourcesContent":["'use strict';\n\nimport stream from 'stream';\nimport utils from '../utils.js';\nimport throttle from './throttle.js';\nimport speedometer from './speedometer.js';\n\nconst kInternals = Symbol('internals');\n\nclass AxiosTransformStream extends stream.Transform{\n  constructor(options) {\n    options = utils.toFlatObject(options, {\n      maxRate: 0,\n      chunkSize: 64 * 1024,\n      minChunkSize: 100,\n      timeWindow: 500,\n      ticksRate: 2,\n      samplesCount: 15\n    }, null, (prop, source) => {\n      return !utils.isUndefined(source[prop]);\n    });\n\n    super({\n      readableHighWaterMark: options.chunkSize\n    });\n\n    const self = this;\n\n    const internals = this[kInternals] = {\n      length: options.length,\n      timeWindow: options.timeWindow,\n      ticksRate: options.ticksRate,\n      chunkSize: options.chunkSize,\n      maxRate: options.maxRate,\n      minChunkSize: options.minChunkSize,\n      bytesSeen: 0,\n      isCaptured: false,\n      notifiedBytesLoaded: 0,\n      ts: Date.now(),\n      bytes: 0,\n      onReadCallback: null\n    };\n\n    const _speedometer = speedometer(internals.ticksRate * options.samplesCount, internals.timeWindow);\n\n    this.on('newListener', event => {\n      if (event === 'progress') {\n        if (!internals.isCaptured) {\n          internals.isCaptured = true;\n        }\n      }\n    });\n\n    let bytesNotified = 0;\n\n    internals.updateProgress = throttle(function throttledHandler() {\n      const totalBytes = internals.length;\n      const bytesTransferred = internals.bytesSeen;\n      const progressBytes = bytesTransferred - bytesNotified;\n      if (!progressBytes || self.destroyed) return;\n\n      const rate = _speedometer(progressBytes);\n\n      bytesNotified = bytesTransferred;\n\n      process.nextTick(() => {\n        self.emit('progress', {\n          'loaded': bytesTransferred,\n          'total': totalBytes,\n          'progress': totalBytes ? (bytesTransferred / totalBytes) : undefined,\n          'bytes': progressBytes,\n          'rate': rate ? rate : undefined,\n          'estimated': rate && totalBytes && bytesTransferred <= totalBytes ?\n            (totalBytes - bytesTransferred) / rate : undefined\n        });\n      });\n    }, internals.ticksRate);\n\n    const onFinish = () => {\n      internals.updateProgress(true);\n    };\n\n    this.once('end', onFinish);\n    this.once('error', onFinish);\n  }\n\n  _read(size) {\n    const internals = this[kInternals];\n\n    if (internals.onReadCallback) {\n      internals.onReadCallback();\n    }\n\n    return super._read(size);\n  }\n\n  _transform(chunk, encoding, callback) {\n    const self = this;\n    const internals = this[kInternals];\n    const maxRate = internals.maxRate;\n\n    const readableHighWaterMark = this.readableHighWaterMark;\n\n    const timeWindow = internals.timeWindow;\n\n    const divider = 1000 / timeWindow;\n    const bytesThreshold = (maxRate / divider);\n    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;\n\n    function pushChunk(_chunk, _callback) {\n      const bytes = Buffer.byteLength(_chunk);\n      internals.bytesSeen += bytes;\n      internals.bytes += bytes;\n\n      if (internals.isCaptured) {\n        internals.updateProgress();\n      }\n\n      if (self.push(_chunk)) {\n        process.nextTick(_callback);\n      } else {\n        internals.onReadCallback = () => {\n          internals.onReadCallback = null;\n          process.nextTick(_callback);\n        };\n      }\n    }\n\n    const transformChunk = (_chunk, _callback) => {\n      const chunkSize = Buffer.byteLength(_chunk);\n      let chunkRemainder = null;\n      let maxChunkSize = readableHighWaterMark;\n      let bytesLeft;\n      let passed = 0;\n\n      if (maxRate) {\n        const now = Date.now();\n\n        if (!internals.ts || (passed = (now - internals.ts)) >= timeWindow) {\n          internals.ts = now;\n          bytesLeft = bytesThreshold - internals.bytes;\n          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;\n          passed = 0;\n        }\n\n        bytesLeft = bytesThreshold - internals.bytes;\n      }\n\n      if (maxRate) {\n        if (bytesLeft <= 0) {\n          // next time window\n          return setTimeout(() => {\n            _callback(null, _chunk);\n          }, timeWindow - passed);\n        }\n\n        if (bytesLeft < maxChunkSize) {\n          maxChunkSize = bytesLeft;\n        }\n      }\n\n      if (maxChunkSize && chunkSize > maxChunkSize && (chunkSize - maxChunkSize) > minChunkSize) {\n        chunkRemainder = _chunk.subarray(maxChunkSize);\n        _chunk = _chunk.subarray(0, maxChunkSize);\n      }\n\n      pushChunk(_chunk, chunkRemainder ? () => {\n        process.nextTick(_callback, null, chunkRemainder);\n      } : _callback);\n    };\n\n    transformChunk(chunk, function transformNextChunk(err, _chunk) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (_chunk) {\n        transformChunk(_chunk, transformNextChunk);\n      } else {\n        callback(null);\n      }\n    });\n  }\n\n  setLength(length) {\n    this[kInternals].length = +length;\n    return this;\n  }\n}\n\nexport default AxiosTransformStream;\n"]},"metadata":{},"sourceType":"module"}